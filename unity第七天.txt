ctrl+shift+f：是一个可以将摄像机快速定位于某一个位置的快捷键

常规的操作想摄像机跟住你想要跟住的对象的操作是：
先将camera拉进去你想要的对象中去，然后制作出来一个空物体，最后把模型拉进去空物体中去

地图相机：创建camera然后改名成为camera
there are 2 audio listeners in the scene，please ensure there is always exactly one audio listener in the sence
错误：解决的方式是
摄像机可以有多个可是耳朵不可以有多个，所以想去mapcamera中的   transform listener去掉
摄像机的调整角度照射的方式就是在transform中的rotation
摄像机中可以调整为2D的是othograph然后就可以处理掉3D的图形处理问题

如何使得小地图中的物体呈现的是一个坐标类似的出现？
就是在物体中的上面用一个小plane跟随物体，然后修改
material 然后修改rendering mode中的OPEQUE就可以实现了

layer 的作用就在于可以消除掉你不想在相机中看到的东西
通过增添层的做法然后再相机中的层取消掉你已经添加的层

不要让地图相机真的看地形因为一个相机就对物体渲染一次
大大增加了渲染的成本导致性能下降，从而不要使用地图相机进行3D视觉
解决方案：首先使用plane放置地图底部，然后让美工制作出来一个地图，然后使用层的
作用就是只看人物头顶上面的图，然后在地图中来回移动就可以大大的减轻游戏的渲染负担

调节小地图的位置与大小
解决方案：在Viewport Rect中的
先调节W H的大小然后再调节位置XY

消除小地图的空白部分：
在mapcamera中的clear Flags调节Depth only就可以实现了

渲染管线：计算机图形学中的知识回去得去看好
面试的时候必考的笔试题目
图形数据在GPU上经过运算处理，最后输出到屏幕的过程

游戏——>图形API——>CPU与GPU分界线——>顶点处理——>图元装配——>光栅化——>像素处理——>缓存
绘制调用Draw Call：每次引擎准备数据并通知GPU的过程，通俗的讲，每帧调用显卡渲染物体的次数

CPU就是判断哪些的物体渲染的东西，GPU就是用来渲染的
Draw Call越大就是渲染的次数越大，所以就是想要降低他
在unity中在哪里可以看呢
解决方案：
stats：Batches中看数据

顶点处理：
接受模型顶点数据
坐标系转换
CPU就是解决接受模型顶点数据用的
增加一个物体就会使得CPU与GPU都会增加他们的工作

图元装配：
组装面：连接相邻的顶点，绘制为三角面

光栅化：计算三角面上的像素，并为后面着色阶段提供合理的插值参数

像素处理：
对每个像素区域进行着色
写入到缓存当中

缓存：
1，一个存储像素数据的内存块，最重要的缓存时帧缓存与深
度缓存
2，帧数存：存储每个像素的色彩，即渲染后的图像。帧缓存
常常在显存中，显卡不断读取并输出到屏幕当中
3，深度缓存 Z-buffer：存储像素的深度信息，即物体到摄像
机的距离。光栅化时便计算各像素的深度值，如果新的深度值
比现有值更近，则像素颜色被写到帧缓存，并且替换深度缓存。


即时遮挡剔除
1，即时遮挡剔除instant occlusion culling
2，遮挡剔除：当物体被送进渲染流水线之前，将摄像机视觉内看不到的物体
进行剔除，从而减少了每帧渲染数据量，提高渲染性能。


插件occlusion culling 
把文件api 导进来
里面有个readme自述文件
IOCcam放进相机里面
































































